name: ü§ñ Automated PrisMind Collection

on:
  schedule:
    - cron: '0 */6 * * *'  # Run every 6 hours
  workflow_dispatch:

jobs:
  collect-reddit-saved:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4
    
    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: üì¶ Install dependencies
      run: |
        python3 -m pip install --upgrade pip
        pip3 install -r requirements.txt
        pip3 install python-dotenv requests
    
    - name: üîç Run Reddit collector
      id: collector
      continue-on-error: true  # Continue even if this step fails
      env:
        REDDIT_CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
        REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
        REDDIT_USER_AGENT: ${{ secrets.REDDIT_USER_AGENT || 'prismind/1.0' }}
        REDDIT_USERNAME: ${{ secrets.REDDIT_USERNAME }}
        REDDIT_PASSWORD: ${{ secrets.REDDIT_PASSWORD }}
      run: |
        # Create required directories
        mkdir -p data logs
        
        # Initialize variables
        OUTPUT=""
        EXIT_CODE=0
        
        # Print environment variables for debugging (without sensitive data)
        echo "::group::Environment Variables"
        env | grep -v 'PASSWORD\|SECRET\|TOKEN' | sort
        echo "::endgroup::"
        
        # Print current directory and files
        echo "::group::Current Directory"
        pwd
        ls -la
        echo "::endgroup::"
        
        # Create an empty output file to ensure it exists
        touch collection_output.txt
        
        # Run the collector and capture output with more detailed logging
        echo "::group::Running Reddit Collector"
        echo "üîç Starting Reddit collector..."
        
        # Run the script with Python's verbose flag to get more detailed error output
        set +e  # Don't fail the step if the command fails
        # Add the project root to PYTHONPATH to ensure imports work correctly
        echo "üîç Python version:"
        python3 --version
        
        # Debug Python environment
        echo "üîç Python environment:"
        python3 -c "import sys; print(sys.path)"
        
        # Debug directory structure
        echo "üîç Current directory structure:"
        find . -type d | sort
        
        # Check for extraction directory and its contents
        echo "üîç Extraction directory contents:"
        find . -type d -name "extraction" | xargs ls -la
        
        # Check for working_reddit_extractor.py
        echo "üîç Looking for working_reddit_extractor.py:"
        find . -name "working_reddit_extractor.py"
        
        # Check __init__.py files
        echo "üîç Checking __init__.py files:"
        find . -name "__init__.py" | xargs cat
        
        # Create any missing __init__.py files
        echo "üîç Ensuring __init__.py files exist in all directories:"
        mkdir -p src/core/extraction
        touch src/__init__.py
        touch src/core/__init__.py
        touch src/core/extraction/__init__.py
        
        # Copy WorkingRedditExtractor if needed
        echo "üîç Ensuring WorkingRedditExtractor is available:"
        if [ -f "src/core/extraction/working_reddit_extractor.py" ]; then
          echo "‚úÖ working_reddit_extractor.py exists"
        else
          echo "‚ö†Ô∏è working_reddit_extractor.py not found, checking for alternative locations"
          find . -name "working_reddit_extractor.py" -exec cp {} src/core/extraction/ \;
          echo "‚úÖ Copied working_reddit_extractor.py to src/core/extraction/"
        fi
        echo "üîç Running with PYTHONPATH set:"
        PYTHONPATH=$(pwd) python3 -v scripts/test_reddit_collector.py > collector_output.txt 2>&1
        EXIT_CODE=$?
        
        # Always save the output, even if the command fails
        OUTPUT=$(cat collector_output.txt || echo "No output captured")
        echo "$OUTPUT" > collection_output.txt
        
        # Print the output for debugging
        echo "üîç Collector output (exit code: $EXIT_CODE):"
        echo "$OUTPUT"
        echo "::endgroup::"
        
        # Save the output to a file for debugging
        echo "::group::Saving debug information"
        echo "üìù Saving debug information to debug_output.txt..."
        echo "Exit Code: $EXIT_CODE" > debug_output.txt
        echo "===== ENVIRONMENT =====" >> debug_output.txt
        env | sort >> debug_output.txt
        echo "\n===== COLLECTOR OUTPUT =====" >> debug_output.txt
        echo "$OUTPUT" >> debug_output.txt
        echo "\n===== FILES IN CURRENT DIRECTORY =====" >> debug_output.txt
        ls -la >> debug_output.txt
        echo "\n===== COLLECTOR SCRIPT =====" >> debug_output.txt
        cat scripts/test_reddit_collector.py >> debug_output.txt 2>/dev/null || echo "Could not read collector script" >> debug_output.txt
        echo "::endgroup::"
        
        # Set job outputs based on results
        if [ $EXIT_CODE -eq 0 ]; then
          NEW_POSTS=$(echo "$OUTPUT" | grep -oP "Collected \d+" | grep -oP '\d+' || echo "0")
          echo "NEW_POSTS=$NEW_POSTS" >> $GITHUB_OUTPUT
          echo "STATUS=success" >> $GITHUB_OUTPUT
          echo "‚úÖ Successfully collected $NEW_POSTS new posts"
        else
          echo "NEW_POSTS=0" >> $GITHUB_OUTPUT
          echo "STATUS=failure" >> $GITHUB_OUTPUT
          echo "‚ùå Reddit collector failed with exit code $EXIT_CODE"
          echo "::error::Reddit collector failed with exit code $EXIT_CODE"
          # Include the error message in the output
          echo "ERROR_MESSAGE=$(echo "$OUTPUT" | head -n 5 | tr '\n' ' ')" >> $GITHUB_OUTPUT
        fi
        
        # Show the output file for debugging
        echo "::group::Collection Output File"
        ls -la collection_output.txt || echo "No collection_output.txt found"
        cat collection_output.txt || true
        echo "::endgroup::"
        
        # Don't exit with error to allow the notification step to run
    
    - name: üì± Send Telegram notification
      if: always()
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        # Debug: Show current directory and file existence
        echo "::group::Current Directory and Files"
        echo "Current directory: $(pwd)"
        ls -la
        echo "::endgroup::"
        
        # Initialize OUTPUT variable
        OUTPUT=""
        
        # Try to read collection output from multiple possible locations
        if [ -f "collection_output.txt" ]; then
          OUTPUT=$(cat collection_output.txt || echo "Error reading collection_output.txt")
          echo "Read from collection_output.txt"
        elif [ -f "$GITHUB_WORKSPACE/collection_output.txt" ]; then
          OUTPUT=$(cat "$GITHUB_WORKSPACE/collection_output.txt" || echo "Error reading $GITHUB_WORKSPACE/collection_output.txt")
          echo "Read from $GITHUB_WORKSPACE/collection_output.txt"
        elif [ -f "collector_output.txt" ]; then
          OUTPUT=$(cat collector_output.txt || echo "Error reading collector_output.txt")
          echo "Read from collector_output.txt"
        elif [ -f "debug_output.txt" ]; then
          OUTPUT=$(head -n 50 debug_output.txt || echo "Error reading debug_output.txt")
          echo "Read from debug_output.txt"
        else
          OUTPUT="No collection output file was found. Check the logs for details."
          echo "::warning::No collection output file found"
        fi
        
        # Get run URL for direct link to logs
        RUN_URL="https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
        
        # Get collector status and new posts count
        COLLECTOR_STATUS="${{ steps.collector.outputs.STATUS || 'failure' }}"
        NEW_POSTS="${{ steps.collector.outputs.NEW_POSTS || '0' }}"
        ERROR_MESSAGE="${{ steps.collector.outputs.ERROR_MESSAGE || 'Unknown error occurred' }}"
        
        echo "Collector status: $COLLECTOR_STATUS"
        echo "New posts: $NEW_POSTS"
        echo "Error message: $ERROR_MESSAGE"
        
        # Format message based on status
        if [ "$COLLECTOR_STATUS" = "success" ]; then
          if [ "$NEW_POSTS" -gt 0 ]; then
            # Extract post titles from the output
            POST_TITLES=$(echo "$OUTPUT" | grep -oP 'Title=\K[^,]*' | head -5 | sed 's/^/‚Ä¢ /')
            EMOJI="üì•"
            MESSAGE="‚úÖ *$NEW_POSTS New Post(s) Collected*\n\n$POST_TITLES"
            if [ "$NEW_POSTS" -gt 5 ]; then
              MESSAGE="$MESSAGE\n\n+$(($NEW_POSTS - 5)) more posts..."
            fi
          else
            EMOJI="‚ÑπÔ∏è"
            MESSAGE="‚ÑπÔ∏è No new posts found on Reddit"
          fi
        else
          EMOJI="‚ùå"
          # Include the error message and first few lines of the output
          ERROR_DETAILS=$(echo "$OUTPUT" | head -n 10 | tr '\n' ' ' | cut -c1-200)
          MESSAGE="‚ùå *Collection Failed*\n\n$ERROR_MESSAGE\n\nError details: $ERROR_DETAILS\n\nCheck the full logs for more information."
        fi
        
        # Get the current time in a nice format
        CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S %Z')
        
        # Format the final message with a clean header and footer
        FINAL_MESSAGE="$EMOJI *Reddit Collection Report*\n*$CURRENT_TIME*\n\n$MESSAGE\n\n[View Run]($RUN_URL)"
        
        # Debug: Show the message that will be sent
        echo "::group::Telegram Message"
        echo "$FINAL_MESSAGE"
        echo "::endgroup::"
        
        # Escape special characters for JSON
        ESCAPED_MESSAGE=$(python3 -c 'import json, sys; print(json.dumps(sys.stdin.read()))' <<< "$FINAL_MESSAGE")
        
        # Send the notification
        echo "Sending Telegram notification..."
        RESPONSE=$(curl -s -X POST \
          -H "Content-Type: application/json" \
          -d "{\"chat_id\": \"$TELEGRAM_CHAT_ID\", \"text\": $ESCAPED_MESSAGE, \"parse_mode\": \"Markdown\", \"disable_web_page_preview\": true}" \
          https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage)
        
        # Check if the request was successful
        if echo "$RESPONSE" | grep -q '"ok":true'; then
          echo "‚úÖ Notification sent successfully"
        else
          echo "::error::Failed to send Telegram notification"
          echo "Response: $RESPONSE"
          exit 1
        fi